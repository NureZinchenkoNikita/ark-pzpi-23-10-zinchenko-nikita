МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ
ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ
УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ
Кафедра «Програмна інженерія»






ЗВІТ
з практичної роботи
з дисципліни «Аналіз та рефакторінг коду»
на тему «Ідіоматичний Rust: Найкращі практики та інструменти кодування для мови, що використовується у високопродуктивних сервісах Google та Meta.»




Виконав:
ст. гр. ПЗПІ-23-10
Зінченко Н.І

Перевірив:
старший викл. Кафедри ПІ
Сокорчук І.П.



Харків 2025
1 ЗАФІКСОВАНІ ЗМІНИ

№

Дата

Версія звіту

Опис змін та
виправлень

1
15.10.2025
0.1
Створення титульної сторінки та написання мети роботи
2
16.10.2025
0.2
Вивчення джерел щодо написання коду на Rust, створення додатку з джерелами, написання прикладів коду для подальшої роботи
3
17.10.2025
0.5
Написаний хід роботи, зроблені висновки по виконаній роботі, заповнення додатків
     
     2 ЗАВДАННЯ
     Мета роботи – дослідити, проаналізувати та систематизувати ключові рекомендації й найкращі практики написання коду мовою програмування Rust. Робота фокусується на визначенні важливості стандартизації стилю кодування для покращення читабельності, підтримуваності та командної роботи. Вона охоплює аналіз стандартної структури проєктів Cargo, принципи поділу коду на модулі, а також офіційні конвенції форматування та іменування. Окрему увагу приділено дослідженню ідіоматичних підходів Rust до обробки помилок через Result та Option, а також ефективних практик коментування й документування коду. Мета також полягає в оцінці ролі вбудованих інструментів, як-от rustfmt та clippy, у підтримці високої якості коду та демонстрації на практичних прикладах різниці між ідіоматичним і неідіоматичним кодом, підкреслюючи їхній вплив на безпеку та ефективність програми.
     
     3 ОПИС ВИКОНАНОЇ РОБОТИ
     
     Хід Роботи
     
     1. Структура коду
     У Rust питання організації проєкту вирішується централізовано завдяки інструменту Cargo. Cargo автоматично створює стандартизовану файлову структуру, що є значною перевагою для командної роботи. Кожен проєкт містить маніфест Cargo.toml, де вказані всі залежності, версія та метадані (Див. додаток В.1). Вихідний код завжди знаходиться у папці src/, з чітким розділенням: src/main.rs використовується як корінь для виконуваного файлу, а src/lib.rs — для бібліотеки. Такий єдиний підхід робить будь-який Rust-проєкт миттєво зрозумілим для нового розробника.
     Логічний поділ коду реалізується через систему модулів (mod) (Див. додаток В.2). На відміну від об'єктно-орієнтованих мов, Rust використовує модулі для інкапсуляції. Ключовою особливістю є те, що всі елементи (функції, структури, самі модулі) є приватними (private) за замовчуванням. Щоб зробити щось доступним поза межами модуля, необхідно явно вказати ключове слово pub. Цей підхід "приватності за замовчуванням" стимулює розробку чітких та захищених публічних API.
     
     2. Форматування коду
     Форматування в Rust стандартизоване, що усуває "священні війни" про стилі, поширені в інших мовах. Спільнота Rust має офіційний інструмент rustfmt, який автоматично форматує код відповідно до єдиного стилю (Див. додаток В.3). Цей стандарт передбачає використання відступів у 4 пробіли (не табуляцію) та "єгипетський" стиль дужок (K&R), коли відкриваюча дужка { ставиться в тому ж рядку, що й оголошення функції чи структури. Також існує "м'яке" обмеження на довжину рядка у 100 символів. Використання команди cargo fmt перед кожним комітом гарантує, що весь код у проєкті виглядає однаково, що значно полегшує читання та код-рев'ю.
     
     3. Іменування
     Конвенції іменування в Rust є чіткими та суворо дотримуються, що допомагає швидко ідентифікувати тип сутності. Усі типи, до яких належать структури (struct), переліки (enum) та трейти (trait), іменуються у стилі PascalCase (ВерблюжийРегістр) (Див. додаток В.4). Натомість, змінні, параметри функцій, назви функцій та модулів завжди пишуться у snake_case (нижній_регістр_через_підкреслення). Для глобальних констант (const) та статичних змінних (static) використовується SCREAMING_SNAKE_CASE (ВЕЛИКІ_ЛІТЕРИ). Важливою практикою є уникнення "магічних чисел". Замість використання числових літералів безпосередньо в логіці, їх слід виносити у const, що робить код зрозумілішим та легшим для підтримки (Див. додаток В.5).
     
     4. Коментарі
     У Rust, як і в інших мовах, коментарі (//) мають пояснювати "чому", а не "що". Ідіоматичний код на Rust має бути достатньо самодокументованим завдяки чітким іменам, щоб пояснювати, що він робить. Коментарі потрібні для пояснення складної бізнес-логіки, неоптимальних, але необхідних компромісів, або обґрунтування вибору певного алгоритму (Див. додаток В.6). Важливо уникати надлишкових коментарів, які просто дублюють код і створюють візуальний шум. Стандартною практикою є використання маркерів // TODO: для позначення завдань, які потрібно виконати, та // FIXME: для відомих проблем, що потребують виправлення, оскільки багато IDE підсвічують їх.
     
     5. Документування коду
     Система документування є однією з найсильніших сторін Rust. Замість звичайних коментарів, використовуються "док-коментарі", які починаються з трьох слешів (///) для опису елемента, що йде за ним (наприклад, функції чи структури), або (//!) для опису елемента, в якому він знаходиться (наприклад, модуля) (Див. додаток В.7). Ці коментарі пишуться у форматі Markdown і підтримують спеціальні секції, такі як # Examples, # Panics (опис умов, за яких функція може панікувати) та # Safety (для unsafe коду). Унікальною особливістю є те, що приклади коду в секції # Examples автоматично компілюються та запускаються як тести командою cargo test, що гарантує актуальність документації. Команда cargo doc --open генерує повноцінний HTML-сайт з документацією.
     
     6. Конвенції стилю кодування для Rust
     Специфічні конвенції Rust глибоко інтегровані в саму мову для забезпечення безпеки та ясності. Ключовою ідіомою є невразливість (immutability) за замовчуванням. Змінні оголошуються через let і стають незмінними; для можливості модифікації потрібно явно вказати let mut. Це робить потік даних у програмі більш прозорим. Іншою фундаментальною конвенцією є обробка помилок. Rust не має null і не використовує винятки (exceptions). Натомість функції, що можуть зазнати невдачі, повертають тип Result<T, E>, а для опціональних значень використовується Option<T> (Див. додаток В.8). Компілятор змушує розробника обробляти обидва випадки (успіх Ok і помилку Err), що запобігає цілому класу помилок. Використання .unwrap() чи .expect(), які викликають паніку (креш програми) у разі помилки, вважається поганою практикою у робочому коді.
     
     7. Кодування на основі тестування (TDD)
     Підхід Test-Driven Development (TDD) у Rust підтримується на рівні мови та стандартних інструментів, тому не потребує сторонніх бібліотек. Unit-тести зазвичай розміщуються в тому ж файлі, що й код, який вони тестують, у спеціальному модулі #[cfg(test)] mod tests (Див. додаток В.9). Цей модуль компілюється лише при запуску команди cargo test, що дозволяє тестувати навіть приватні функції. Інтеграційні тести, що перевіряють публічний API, розміщуються в окремій директорії tests/ у корені проєкту. Тестові функції позначаються атрибутом #[test], а атрибут #[should_panic] дозволяє перевірити, що код коректно панікує за очікуваних умов.
     
     8. Інструменти та автоматизація для підтримки якості коду
     Якість коду в Rust підтримується потужною екосистемою інструментів. Найголовнішим "статичним аналізатором" є сам компілятор rustc з його системою перевірки власності (Borrow Checker), який запобігає цілим класам помилок пам'яті ще на етапі компіляції. Для аналізу стилю та пошуку неідіоматичних конструкцій використовується офіційний лінтер clippy (Див. додаток В.10). clippy надає сотні порад, від виправлення потенційних помилок до рекомендацій щодо покращення продуктивності та читабельності коду. Ці інструменти легко інтегруються в CI/CD, а команди cargo check (для швидкої перевірки) та cargo clippy (для повного аналізу) стають невід'ємною частиною робочого процесу.
     
     9. Загальні приклади оформлення коду та їх аналіз
     Аналіз прикладів найкраще демонструє різницю між ідіоматичним та неідіоматичним кодом на Rust. "Поганий" код часто містить практики з інших мов, які є небезпечними в Rust: наприклад, використання .unwrap() або .expect(), що призводить до паніки, або надмірне використання let mut (Див. додаток В.11). Також сюди можна віднести імперативні цикли в стилі C з ручним керуванням індексами.
     "Хороший", ідіоматичний код на Rust, натомість, завжди коректно обробляє Result та Option (через match, if let або оператор ?). Крім того, він надає перевагу функціональним конструкціям, таким як ітератори (.map(), .filter(), .collect()), замість ручних циклів (Див. додаток В.12). Ці "абстракції з нульовою вартістю" компілюються в такий самий ефективний машинний код, але є значно безпечнішими та чистішими для читання, що прямо впливає на продуктивність команди.
     
     4 ВИСНОВКИ
     	У ході виконання даної роботи було проаналізовано та систематизовано ключові рекомендації щодо написання коду мовою програмування Rust. Дослідження показало, що на відміну від багатьох інших мов, стандарти кодування в Rust тісно інтегровані в саму екосистему та спрямовані не лише на читабельність, але й на забезпечення фундаментальних принципів мови: безпеки пам’яті та ефективності.
     	Було встановлено, що інструмент Cargo відіграє центральну роль, стандартизуючи структуру проєктів, керування залежностями та процеси збірки. Це, у поєднанні з офіційним форматувальником rustfmt, усуває суб’єктивні суперечки щодо стилю та забезпечує єдиний вигляд кодової бази. Чіткі конвенції іменування (PascalCase для типів, snake_case для функцій та змінних) та система модулів з приватністю за замовчуванням (pub) сприяють створенню зрозумілих та надійних API.
     	Головний висновок полягає в тому, що ідіоматичний код на Rust вимагає прийняття його унікальних концепцій. Найважливішою з них є відмова від винятків та null на користь явних типів Result<T, E> та Option<T>. Компілятор змушує розробника обробляти помилки, що кардинально підвищує надійність програм. Зловживання методами .unwrap() та .expect(), хоч і можливе, було визначено як головний антипатерн, що нівелює гарантії безпеки Rust.
     	Крім того, робота підкреслила важливість вбудованих інструментів. Лінтер clippy виступає як незамінний помічник для пошуку неідіоматичного коду, а система документації (/// та cargo doc) з можливістю тестування прикладів коду забезпечує високу якість супровідної документації. Таким чином, дотримання проаналізованих правил та активне використання інструментів clippy, rustfmt і cargo test є не просто "хорошою практикою", а фундаментальною необхідністю для ефективної та безпечної розробки на Rust.
     
     	5 ВИКОРИСТАНІ ДЖЕРЕЛА
     1. "The Rust Programming Language". URL: https://rust-lang-ua.github.io/rustbook_ukrainian/ (Дата звернення 18.10.2025)
     2. Офіційна документація clippy. URL: https://doc.rust-lang.org/clippy/ (Дата звернення 18.10.2025)
     3. Rust by example. URL: https://doc.rust-lang.org/rust-by-example/ (Дата звернення 18.10.2025)
     4. The Cargo Book. URL: https://doc.rust-lang.org/cargo/index.html (Дата звернення 18.10.2025)
     5. Rust (programming language) URL: https://en.wikipedia.org/wiki/Rust_(programming_language) (Дата звернення 18.10.2025)
     
     Додаток А
     Відеозапис
     Відеозапис доповіді: https://www.youtube.com/watch?v=7AN7jHvYCXU 
     Хронологічний опис відеозапису:
      00:00 Вступ
      00:40 Організація проєкту та файлів 
      01:22 Принципи логічного поділу 
      01:55 Відступи, вирівнювання та дужки 
      02:45 Іменування та "магічні числа" 
      03:28 Коли та де використовувати коментарі 
      04:20 Спеціалізовані коментарі для документації 
      05:08 Ідіоми Rust: Безпека та Ясність 
      05:39 Статичний аналіз та інструменти 
      06:06 Кодування на основі тестування 
      06:46 Приклади: Погано vs Добре 
      07:32 Висновки та Джерела
     
     ДОДАТОК Б
     Слайди презентації

Рисунок Б.1 — Титульний слайд презентації


Рисунок Б.2 — Стандартна організація проєкту та файлів у Rust

Рисунок Б.3 — Принципи логічного поділу коду на модулі


Рисунок Б.4 — Правила форматування коду: відступи та дужки

Рисунок Б.5 — Конвенції іменування та використання констант


Рисунок Б.6 — Рекомендації щодо використання коментарів

Рисунок Б.7 — Використання коментарів для документації (doc-comments)

Рисунок Б.8 — Ідіоматичні підходи до безпеки та обробки помилок


Рисунок Б.9 — Інструменти статичного аналізу: rustc та clippy

Рисунок Б.10 — Вбудована система тестування в Rust
Рисунок Б.11 — Приклади поганого та ідіоматичного (доброго) коду


Рисунок Б.12 — Висновки роботи та використані джерела

     ДОДАТОК В
     Програмний код
     В.1 Приклад стандартної структури проєкту Cargo 
     GitHub репозиторій: https://github.com/NureZinchenkoNikita/ark-pzpi-23-10-zinchenko-nikita/blob/main/Pract1/ark-pzpi-23-10-zinchenko-nikita-pract1/Code%20examples.rs
      1  // Стандартна структура проєкту, згенерована `cargo new`:
      2  
      3  // Cargo.toml (Маніфест проєкту)
      4  // [package]
      5  // name = "my_project"
      6  // version = "0.1.0"
      7  // edition = "2021"
      8  // 
      9  // [dependencies]
     10  // # ...
     11  
     12  // src/main.rs (Корінь бінарного проєкту)
     13  // fn main() {
     14  //     println!("Hello, world!");
     15  // }
     16  
     17  // src/lib.rs (Корінь бібліотечного проєкту)
     18  // pub fn my_lib_function() {
     19  //     // ...
     20  // }
     21  
     22  // tests/integration_test.rs (Інтеграційні тести)
     23  // #[test]
     24  // fn it_works() {
     25  //     assert_eq!(2 + 2, 4);
     26  // }
     В.2 Приклад логічного поділу коду на модулі 
     GitHub репозиторій: https://github.com/NureZinchenkoNikita/ark-pzpi-23-10-zinchenko-nikita/blob/main/Pract1/ark-pzpi-23-10-zinchenko-nikita-pract1/Code%20examples.rs
      1  // у src/lib.rs
      2  pub mod front_of_house {
      3      pub mod hosting {
      4          pub fn add_to_waitlist() {}
      5      }
      6  
      7      mod serving { // Приватний модуль
      8          fn take_order() {}
      9      }
     10  }
     11  
     12  // `use` для імпорту
     13  use crate::front_of_house::hosting;
     14  
     15  pub fn eat_at_restaurant() {
     16      hosting::add_to_waitlist(); // OK
     17      // front_of_house::serving::take_order(); // Помилка! 'serving' - приватний
     18  }
     В.3 Приклад роботи форматувальника rustfmt 
     GitHub репозиторій: https://github.com/NureZinchenkoNikita/ark-pzpi-23-10-zinchenko-nikita/blob/main/Pract1/ark-pzpi-23-10-zinchenko-nikita-pract1/Code%20examples.rs
      1  // 'rustfmt' автоматично перетворить...
      2  fn 
      3  my_function(
      4      x:i32
      5  ) 
      6      -> i32 {
      7          x+1
      8  }
      9  
     10  // ...на ось це:
     11  fn my_function(x: i32) -> i32 {
     12      x + 1
     13  }
     В.4 Приклад конвенцій іменування 
     GitHub репозиторій: https://github.com/NureZinchenkoNikita/ark-pzpi-23-10-zinchenko-nikita/blob/main/Pract1/ark-pzpi-23-10-zinchenko-nikita-pract1/Code%20examples.rs
      1  // Добре (Відповідно до конвенцій Rust)
      2  struct UserProfile { // PascalCase
      3      user_name: String, // snake_case
      4  }
      5  
      6  fn get_user_profile(user: &UserProfile) { // snake_case
      7      // ...
      8  }
      9  
     10  // Погано (Неідіоматично)
     11  struct user_profile { // не PascalCase
     12      UserName: String, // не snake_case
     13  }
     В.5 Приклад використання констант замість "магічних чисел" 
     GitHub репозиторій: https://github.com/NureZinchenkoNikita/ark-pzpi-23-10-zinchenko-nikita/blob/main/Pract1/ark-pzpi-23-10-zinchenko-nikita-pract1/Code%20examples.rs
      1  // Добре: Використання константи
      2  const MAX_LOGIN_ATTEMPTS: u32 = 3; // SCREAMING_SNAKE_CASE
      3  
      4  fn login(attempts: u32) {
      5      if attempts >= MAX_LOGIN_ATTEMPTS {
      6          // ...
      7      }
      8  }
      9  
     10  // Погано: Використання "магічного числа"
     11  fn login_bad(attempts: u32) {
     12      if attempts >= 3 { // '3' - магічне число
     13          // ...
     14      }
     15  }
     В.6 Приклад правильного та неправильного коментування 
     GitHub репозиторій: https://github.com/NureZinchenkoNikita/ark-pzpi-23-10-zinchenko-nikita/blob/main/Pract1/ark-pzpi-23-10-zinchenko-nikita-pract1/Code%20examples.rs
      1  // Погано: коментар пояснює "Що"
      2  // Додаємо 1 до x
      3  let x = 0;
      4  x += 1;
      5  
      6  // Добре: коментар пояснює "Чому"
      7  // Ми повинні збільшити лічильник через вимоги протоколу X
      8  let x = 0;
      9  x += 1;
     10  
     11  // TODO: для позначення майбутньої роботи
     12  // FIXME: для позначення відомої помилки, що потребує виправлення
     В.7 Приклад коментарів для документації (doc-comments) 
     GitHub репозиторій: https://github.com/NureZinchenkoNikita/ark-pzpi-23-10-zinchenko-nikita/blob/main/Pract1/ark-pzpi-23-10-zinchenko-nikita-pract1/Code%20examples.rs
      1  /// Додає два числа.
      2  ///
      3  /// # Examples
      4  ///
      5  /// ```
      6  /// // Цей код буде виконано під час `cargo test`
      7  /// assert_eq!(my_lib::add(2, 2), 4);
      8  /// ```
      9  ///
     10  /// # Panics
     11  /// Ця функція ніколи не панікує.
     12  ///
     13  /// # Safety
     14  /// Ця функція є безпечною для виклику.
     15  pub fn add(left: usize, right: usize) -> usize {
     16      left + right
     17  }
     В.8 Приклад ідіоматичної обробки помилок 
     GitHub репозиторій: https://github.com/NureZinchenkoNikita/ark-pzpi-23-10-zinchenko-nikita/blob/main/Pract1/ark-pzpi-23-10-zinchenko-nikita-pract1/Code%20examples.rs
      1  // Добре: Ідіоматична обробка помилок через `Result` та оператор `?`
      2  fn get_config_value() -> Result<String, std::io::Error> {
      3      let mut file = std::fs::File::open("config.txt")?; // '?' прокидає помилку
      4      let mut contents = String::new();
      5      file.read_to_string(&mut contents)?;
      6      Ok(contents)
      7  }
      8  
      9  // Погано: Використання .unwrap(), що призведе до паніки (крешу)
     10  fn get_config_value_bad() -> String {
     11      let file = std::fs::File::open("config.txt").unwrap(); // Панікує, якщо файл не знайдено
     12      // ...
     13      String::new()
     14  }
     В.9 Приклад написання unit-тестів 
     GitHub репозиторій: https://github.com/NureZinchenkoNikita/ark-pzpi-23-10-zinchenko-nikita/blob/main/Pract1/ark-pzpi-23-10-zinchenko-nikita-pract1/Code%20examples.rs
      1  // Функція, яку ми тестуємо
      2  pub fn add(a: i32, b: i32) -> i32 {
      3      a + b
      4  }
      5  
      6  // Модуль `tests` знаходиться в тому ж файлі
      7  #[cfg(test)] // Цей модуль компілюється тільки при `cargo test`
      8  mod tests {
      9      use super::*; // Імпортуємо `add` з батьківського модуля
     10  
     11      #[test] // Позначаємо функцію як unit-тест
     12      fn it_works() {
     13          assert_eq!(add(2, 2), 4);
     14      }
     15  
     16      #[test]
     17      #[should_panic] // Тест, який перевіряє, що функція панікує
     18      fn test_panic_example() {
     19          // panic!("Цей тест має впасти");
     20      }
     21  }
     В.10 Приклад виклику інструментів статичного аналізу 
     GitHub репозиторій: https://github.com/NureZinchenkoNikita/ark-pzpi-23-10-zinchenko-nikita/blob/main/Pract1/ark-pzpi-23-10-zinchenko-nikita-pract1/Code%20examples.rs
      1  // Використання інструментів у терміналі
      2  
      3  // 1. Швидка перевірка синтаксису та помилок (без компіляції)
      4  // $ cargo check
      5  
      6  // 2. Аналіз стилю та пошук неідіоматичного коду
      7  // $ cargo clippy
     В.11 Приклад неідіоматичного ("поганого") коду 
     GitHub репозиторій: https://github.com/NureZinchenkoNikita/ark-pzpi-23-10-zinchenko-nikita/blob/main/Pract1/ark-pzpi-23-10-zinchenko-nikita-pract1/Code%20examples.rs
      1  // ПОГАНО: панікує, якщо `value` не є числом
      2  fn parse_bad(value: &str) -> i32 {
      3      // .unwrap() призведе до крешу програми, якщо parse поверне Err
      4      value.parse::<i32>().unwrap()
      5  }
      6  
      7  // ПОГАНО: імперативний C-стиль з ручним керуванням індексами
      8  fn double_values_bad() {
      9      let mut v = vec![1, 2, 3];
     10      let mut v2 = vec![];
     11      for i in 0..v.len() {
     12          v2.push(v[i] * 2);
     13      }
     14  }
     В.12 Приклад ідіоматичного ("доброго") коду 
     GitHub репозиторій: https://github.com/NureZinchenkoNikita/ark-pzpi-23-10-zinchenko-nikita/blob/main/Pract1/ark-pzpi-23-10-zinchenko-nikita-pract1/Code%20examples.rs
      1  // ДОБРЕ: повертає помилку, яку можна обробити
      2  fn parse_good(value: &str) -> Result<i32, std::num::ParseIntError> {
      3      // Функція повертає `Result`, дозволяючи тому, хто її викликав,
      4      // вирішити, що робити з помилкою.
      5      value.parse::<i32>()
      6  }
      7  
      8  // ДОБРЕ: функціональний стиль з нульовою вартістю (0-cost abstraction)
      9  fn double_values_good() {
     10      let v = vec![1, 2, 3];
     11      // .iter().map().collect() - ідіоматично, безпечно 
     12      // і компілюється в такий самий швидкий код, як і цикл for.
     13      let v2: Vec<i32> = v.iter().map(|x| x * 2).collect();
     14  }
     

